# #   1. 尝试一下将数据（'F': 70, 'C': 67, 'h': 104, 'i': 105, 's': 115）创建为一个字典并访问键 'C' 对应的值？
# dict1 = {'F': 70, 'C': 67, 'h': 104, 'i': 105, 's': 115}
# print('C对应的是', dict1["C"])
# # C对应的是 67

# 2. 用方括号（“[]”）括起来的数据我们叫列表，那么使用大括号（“{}”）括起来的数据我们就叫字典，对吗？
# 答：不对。
# NotADict = {1, 2, 3, 4, 5}
# type(NotADict)
# <class 'set'>
# 不难发现，虽然我们用大括号（“{}”）把一些数据括起来了，但由于没有反映出这些数据有映射的关系，所以创建出来的不是字典，


# # 3. 你如何理解有些东西字典做得到，但“万能的”列表却难以实现（臣妾做不到T_T）？
# brand = ['李宁', '耐克', '阿迪达斯', '鱼C工作室']
# slogan = ['一切皆有可能', 'Just do it', 'Impossible is nothing', '让编程改变世界']
# print('鱼C工作室的口号是：', slogan[brand.index('鱼C工作室')])
# # 列表brand、slogan的索引和相对的值是没有任何关系的，我们可以看出唯一有联系的就是两个列表间，索引号相同的元素是有关系的（品牌对应口号嘛），所以这里我们通过brand.index('鱼C工作室')
# # 这样的语句，间接的实现通过品牌查找对应的口号的功能。
# # 这确实是一种可实现方法，呃……但用起来呢，多少有些别扭，效率还不高咧。况且Python是以简洁为主，这样子的实现肯定是不能让人满意的，所以呢，我们需要有字典这种映射类型的出现：
# dict1 = {'李宁': '一切皆有可能', '耐克': 'Just do it', '阿迪达斯': 'Impossible is nothing', '鱼C工作室': '让编程改变世界'}
# print('鱼C工作室的口号是：', dict1['鱼C工作室'])
# # 鱼C工作室的口号是： 让编程改变世界
# # 鱼C工作室的口号是： 让编程改变世界


# # 4. 下边这些代码，他们都在执行一样的操作吗？你看得出差别吗？
# a = dict(one=1, two=2, three=3)
# b = {'one': 1, 'two': 2, 'three': 3}
# c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
# d = dict([('two', 2), ('one', 1), ('three', 3)])
# e = dict({'three': 3, 'one': 1, 'two': 2})
# print(a, b, c, d, e)
# # 答：是的，他们都在创建字典：a = dict(one=1, two=2, three=3)，呃，我是看不出差别啦~
# # {'one': 1, 'two': 2, 'three': 3} {'one': 1, 'two': 2, 'three': 3}
# # {'one': 1, 'two': 2, 'three': 3} {'two': 2, 'one': 1, 'three': 3} {'three': 3, 'one': 1, 'two': 2}

# data = "1000,小甲鱼,男"
# MyDict = {}
# # 还记得字符串的分割方法吧，别学过就忘啦^_^
# (MyDict['id'], MyDict['name'], MyDict['sex']) = data.split(',')
# print(" ID:   ", MyDict['id'])
# print("Name: ", MyDict['name'])
# print("Sex:  ", MyDict['sex'])
# #  ID:    1000
# # Name:  小甲鱼
# # Sex:   男
