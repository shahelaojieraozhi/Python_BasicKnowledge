# 1. 递归必须满足哪两个基本条件？
# 一、函数调用自身 -->return 后面有本身的这个函数
# 二、设置了正确的返回条件
#
# 2. 思考一下，按照递归的特性，在编程中有没有不得不使用递归的情况？
# 答：例如汉诺塔，目录索引（因为你永远不知道这个目录里边是否还有目录），快速排序（二十世纪十大算法之一），树结构的定义等如果使用递归，会事半功倍，否则会导致程序无法实现或相当难以理解。
#
# 3. 用递归去计算阶乘问题或斐波那契数列是很糟糕的算法，你知道为什么吗？
# 答：小甲鱼在课程的开头说“普通程序员用迭代，天才程序员用递归”这句话是不无道理的。
# 但是你不要理解错了，不是说会使用递归，把所有能迭代的东西用递归来代替就是“天才程序员”了，恰好相反，如果你真的这么做的话，那你就是“乌龟程序员”啦。
# 为什么这么说呢？不要忘了，递归的实现可以是函数自个儿调用自个儿，每次函数的调用都需要进行压栈、弹栈、保存和恢复寄存器的栈操作，所以在这上边是非常消耗时间和空间的。
# 另外，如果递归一旦忘记了返回，或者错误的设置了返回条件，那么执行这样的递归代码就会变成一个无底洞：只进不出！所以在写递归代码的时候，千万要记住口诀：递归递归，归去来兮！出来混，总有一天是要还的！
#
# 4. 请聊一聊递归的优缺点（无需官方陈词，想到什么写什么就可以）
# 优点：
# 1）递归的基本思想是把规模大的问题转变成规模小的问题组合，从而简化问题的解决难度（例如汉诺塔游戏）。
# 2）有些问题使用递归使得代码简洁易懂（例如你可以很容易的写出前中后序的二叉树遍历的递归算法，但如果要写出相应的非递归算法就不是初学者可以做到的了。）
# 缺点：
# 1）由于递归的原理是函数调用自个儿，所以一旦大量的调用函数本身空间和时间消耗是“奢侈的”（当然法拉利也奢侈，但还是很多人趋之若鹜）。
# 2）初学者很容易错误的设置了返回条件，导致递归代码无休止调用，最终栈溢出，程序崩溃。

# # 先来个简单例子
# def f(x):
#     if x > 0:
#         return x + f(x - 1)
#     else:
#         return 0
#
#
# print(f(100))

# 递归三部曲：
# 1、递归函数的参数的返回值
# 2、确定终止条件
# 3、单层递归的逻辑

# # use for grammar loop for factorial(算阶乘)
# def factorial1(x):
#     sum1 = 1
#     for i in range(1, x + 1):
#         sum1 = sum1 * i
#         print(sum1)
#
#
# print(factorial1(5))


# # paradigm(范例) by little turtle   还是迭代
# def factorial(n):
#     result1 = n
#     for i in range(1, n):
#         result1 *= i
#     return result1
#
#
# number = int(input('请输入一个正整数：'))
# result = factorial(number)
# print('%d 的阶乘是： %d' % (number, result))
# #  %d：格式化整数


# # using recursion:
# def factorial(n):
#     if n == 1:
#         return 1
#     else:
#         return n * factorial(n - 1)
#     #   设 n = 3, factorial(3) = 3 * factorial（2） = 3 * 2 * factorial（1） = 3*2*1
#
#
# number = int(input('请输入一个正整数：'))
# result = factorial(number)
# print('%d 的阶乘是： %d' % (number, result))


# # #**********动动手***************
# # 0. 使用递归编写一个 power() 函数模拟内建函数 pow()，即 power(x, y) 为计算并返回 x 的 y 次幂的值。
# def power(x, y):
#     if y == 0:
#         return 1
#     else:
#         return x * power(x, y - 1)
#
#
# print(power(2, 8))


# # paradigm by little turtle
# def power(x, y):
#     if y:
#         return x * power(x, y - 1)
#     else:
#         return 1
#
#
# print(power(2, 3))

# # #**********说明***************
# 它不是说直接乘以后面的参数，而是乘以上次调用的结果。
# 这里的return 1很重要，return 1是说y=0时函数运行结果返回1，这个y-1总会等于0，那么我们就从0开始倒着算，
# 如果参数是2，4，你可以把这个过程分解为：
# y=0那次执行函数返回1；
# y=1那次返回的是2*1 = 2；
# y=2那次返回的是2*(2*1) = 4;此处加括号为了看起来明了。
# y=3那次返回的是2*(2*(2*1)) = 8;
# y=4那次返回的是2*(2*(2*(2*1))) = 16。
# 这个过程也印证了为什么递归的两个基本条件的第二条 “设置了正确的返回条件


# #1. 使用递归编写一个函数，利用欧几里得算法求最大公约数，例如 gcd(x, y) 返回值为参数 x 和参数 y 的最大公约数。
# 欧几里得算法又称辗转相除法，用于求两个正整数a,b的最大公约数
def gcd(x, y):
    if y:
        return gcd(y, x % y)
    else:
        return x


print(gcd(45, 36))
